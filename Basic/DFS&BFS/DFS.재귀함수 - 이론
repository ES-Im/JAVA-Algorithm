// 재귀함수(자기자신을 호출하는 함수)
// 재귀함수는 스택 프레임을 사용한다

// 1.자연수 N이 입력되면 재귀함수를 이용하여 1부터 N까지 출력하는 프로그램을 작성
public class Main {
    static void DFS(int n) {
        if(n == 0) return;
        DFS(n-1);           // 1 2 3
        System.out.println(n);
        //DFS(n-1);           // 3 2 1
    }

    public static void main(String[] args) {
        DFS(3);
    }
}

// 2. 10진수 N이 입력되면 2진수로 변환하여 출력하는 프로그램 작성
public class Main {
    static void DFS(int n) {
        if(n == 0) return;
        DFS(n/2);
        System.out.printf("%d ",n%2);
    }

    public static void main(String[] args) {
        DFS(11);
    }
}

// 3. 팩토리얼 계산

public class Main {
    static int DFS(int n) {
        if(n == 1) return 1;
        return n*DFS(n-1);
    }

    public static void main(String[] args) {
        System.out.println(DFS(5));
    }
}

// 4. 피보나치 수열 : 재귀가 호출될때마다 스택프레임이 만들어지고 연산이 됌 -> 무거움

public class Main {

    static int DFS(int n) {
        if(n == 1) return 1;            // 첫번째 항
        else if (n == 2) return 1;      // 두번째 항
        else return DFS(n-2) + DFS(n-1);    // 세번째 ~ (앞에앞에 + 앞에)
    }

    public static void main(String[] args) {
        for (int i = 1; i < 10; i++)
        System.out.printf("%d ", DFS(i));
    }
}

// 4-1. static 배열을 사용하여 피보나치 배열 개선 : 메모리제이션을 활용, 이미 연산된 스택을 호출
public class Main {
    static int[] fibo;

    static int DFS(int n) {
        if(fibo[n] > 0) return fibo[n];

        if(n == 1) return fibo[n] = 1;            // 첫번째 항
        else if (n == 2) return fibo[n] = 1;      // 두번째 항
        else return fibo[n] = DFS(n-2) + DFS(n-1);    // 세번째 ~ (앞에앞에 + 앞에)
    }

    public static void main(String[] args) {
        int n = 45;
        fibo = new int[n+1];    // 각 DFS를 저장할 배열
        DFS(n);
        for (int i = 1; i < n; i++)
        System.out.printf("%d ", fibo[i]);
    }

}






